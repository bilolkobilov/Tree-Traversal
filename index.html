<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Tree Traversal Calculator</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <!-- Vis.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <!-- html2canvas for PNG export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.3.2/html2canvas.min.js"></script>
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
        }
        .tab {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .tab.active {
            border-bottom: 2px solid #3B82F6;
            color: #3B82F6;
            font-weight: 500;
        }
        #network {
            width: 100%;
            height: 450px;
            border: 1px solid #e5e7eb;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .custom-tool-btn {
            transition: all 0.2s ease;
        }
        .custom-tool-btn:hover {
            transform: translateY(-2px);
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            animation: slideDown 0.3s;
        }
        @keyframes fadeIn {
            from {opacity: 0}
            to {opacity: 1}
        }
        @keyframes slideDown {
            from {transform: translateY(-50px); opacity: 0;}
            to {transform: translateY(0); opacity: 1;}
        }
        /* Custom node styling */
        .node-highlight {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 120px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* Toast notification */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            border-radius: 4px;
            background-color: #333;
            color: white;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
            max-width: 250px;
        }
        .toast.show {
            opacity: 1;
        }
        .toast.success {
            background-color: #10B981;
        }
        .toast.error {
            background-color: #EF4444;
        }
        .toast.info {
            background-color: #3B82F6;
        }
        /* Animation classes */
        .animate-fade-in {
            animation: fadeIn 0.5s ease forwards;
        }
        .animate-slide-in {
            animation: slideIn 0.5s ease forwards;
        }
        @keyframes slideIn {
            from {
                transform: translateX(30px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header with improved styling -->
    <header class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8 flex justify-between items-center">
            <div class="flex items-center">
                <h1 class="text-2xl font-bold text-gray-900 flex items-center">
                    <i class="fas fa-project-diagram text-blue-500 mr-2"></i>
                    Advanced Tree Traversal
                </h1>
                <span class="ml-2 px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded-md">Pro</span>
            </div>
            <div class="flex items-center space-x-4">
                <button id="helpBtn" class="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-full transition-all">
                    <i class="fas fa-question-circle"></i>
                </button>
                <button id="settingsBtn" class="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-full transition-all">
                    <i class="fas fa-cog"></i>
                </button>
                <div class="relative">
                    <button id="themeToggle" class="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-full transition-all">
                        <i class="fas fa-moon"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main content with improved layout -->
    <main class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- Left sidebar for input and controls -->
            <div class="lg:col-span-1">
                <!-- Input card -->
                <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden mb-6">
                    <div class="px-4 py-5 border-b border-gray-200 bg-gray-50">
                        <h2 class="text-lg font-medium text-gray-900 flex items-center">
                            <i class="fas fa-keyboard text-blue-500 mr-2"></i>
                            Input Methods
                        </h2>
                    </div>
                    
                    <!-- Input method tabs with improved styling -->
                    <div class="flex border-b border-gray-200">
                        <div id="textTabBtn" class="tab px-4 py-3 text-sm font-medium active">
                            <i class="fas fa-font mr-1"></i> Text
                        </div>
                        <div id="jsonTabBtn" class="tab px-4 py-3 text-sm font-medium">
                            <i class="fas fa-code mr-1"></i> JSON
                        </div>
                        <div id="visualTabBtn" class="tab px-4 py-3 text-sm font-medium">
                            <i class="fas fa-pencil-alt mr-1"></i> Visual
                        </div>
                    </div>
                    
                    <!-- Text input with improved styling -->
                    <div id="textInputTab" class="p-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Enter values separated by commas</label>
                        <input type="text" id="treeTextInput" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition-all" value="1,2,3,4,5,6,7">
                        <p class="text-xs text-gray-500 mt-1">For binary trees, use 'null' for empty nodes</p>
                    </div>
                    
                    <!-- JSON input with syntax highlighting -->
                    <div id="jsonInputTab" class="p-4 hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">JSON format</label>
                        <textarea id="treeJsonInput" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 transition-all h-32 font-mono text-sm">{"value": 1, "left": {"value": 2, "left": {"value": 4}, "right": {"value": 5}}, "right": {"value": 3, "left": {"value": 6}, "right": {"value": 7}}}</textarea>
                        <p class="text-xs text-gray-500 mt-1">Format: {"value": x, "left": {...}, "right": {...}}</p>
                    </div>
                    
                    <!-- Visual input with better instructions -->
                    <div id="visualInputTab" class="p-4 hidden">
                        <p class="text-sm text-gray-700 mb-3">
                            <span class="flex items-center mb-1"><i class="fas fa-mouse-pointer text-blue-500 mr-2"></i> Double-click: Add a new node</span>
                            <span class="flex items-center mb-1"><i class="fas fa-arrows-alt text-blue-500 mr-2"></i> Drag: Move nodes around</span>
                            <span class="flex items-center"><i class="fas fa-link text-blue-500 mr-2"></i> Click nodes: Create connections</span>
                        </p>
                        <div class="flex space-x-2">
                            <button id="clearGraphBtn" class="flex items-center justify-center px-3 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-all">
                                <i class="fas fa-trash-alt mr-1"></i> Clear Graph
                            </button>
                            <button id="autoLayoutBtn" class="flex items-center justify-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                                <i class="fas fa-magic mr-1"></i> Auto Layout
                            </button>
                        </div>
                    </div>
                    
                    <!-- Action buttons with improved styling -->
                    <div class="px-4 py-3 bg-gray-50 border-t border-gray-200">
                        <div class="flex space-x-2">
                            <button id="generateTreeBtn" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                                <i class="fas fa-sync-alt mr-1"></i> Generate Tree
                            </button>
                            <button id="analyzeTreeBtn" class="flex-1 flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all">
                                <i class="fas fa-calculator mr-1"></i> Analyze
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Tools card -->
                <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden mb-6">
                    <div class="px-4 py-5 border-b border-gray-200 bg-gray-50">
                        <h2 class="text-lg font-medium text-gray-900 flex items-center">
                            <i class="fas fa-tools text-blue-500 mr-2"></i>
                            Tools
                        </h2>
                    </div>
                    <div class="p-4 grid grid-cols-2 gap-3">
                        <button id="downloadPngBtn" class="custom-tool-btn flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg bg-white hover:bg-gray-50 transition-all">
                            <i class="fas fa-download text-purple-500 text-lg mb-1"></i>
                            <span class="text-xs font-medium text-gray-700">PNG Export</span>
                        </button>
                        <button id="downloadSvgBtn" class="custom-tool-btn flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg bg-white hover:bg-gray-50 transition-all">
                            <i class="fas fa-file-image text-indigo-500 text-lg mb-1"></i>
                            <span class="text-xs font-medium text-gray-700">SVG Export</span>
                        </button>
                        <button id="saveTreeBtn" class="custom-tool-btn flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg bg-white hover:bg-gray-50 transition-all">
                            <i class="fas fa-save text-blue-500 text-lg mb-1"></i>
                            <span class="text-xs font-medium text-gray-700">Save Tree</span>
                        </button>
                        <button id="loadTreeBtn" class="custom-tool-btn flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg bg-white hover:bg-gray-50 transition-all">
                            <i class="fas fa-folder-open text-yellow-500 text-lg mb-1"></i>
                            <span class="text-xs font-medium text-gray-700">Load Tree</span>
                        </button>
                    </div>
                </div>
                
                <!-- Examples card -->
                <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden">
                    <div class="px-4 py-5 border-b border-gray-200 bg-gray-50">
                        <h2 class="text-lg font-medium text-gray-900 flex items-center">
                            <i class="fas fa-lightbulb text-blue-500 mr-2"></i>
                            Examples
                        </h2>
                    </div>
                    <div class="p-3">
                        <button class="example-tree-btn w-full text-left p-2 border border-gray-200 rounded-md mb-2 hover:bg-gray-50 transition-all" data-values="1,2,3,4,5,6,7">
                            <div class="font-medium text-sm">Perfect Binary Tree</div>
                            <div class="text-xs text-gray-500">Complete tree with all levels filled</div>
                        </button>
                        <button class="example-tree-btn w-full text-left p-2 border border-gray-200 rounded-md mb-2 hover:bg-gray-50 transition-all" data-values="10,5,15,3,7,null,18">
                            <div class="font-medium text-sm">Binary Search Tree</div>
                            <div class="text-xs text-gray-500">Follows BST property</div>
                        </button>
                        <button class="example-tree-btn w-full text-left p-2 border border-gray-200 rounded-md hover:bg-gray-50 transition-all" data-values="1,2,null,3,null,4,null,5">
                            <div class="font-medium text-sm">Skewed Tree</div>
                            <div class="text-xs text-gray-500">Nodes lean to one side</div>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Main content area - expanded to 3 columns -->
            <div class="lg:col-span-3">
                <!-- Tree visualization and info card -->
                <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden mb-6">
                    <!-- Tree type banner with better styling -->
                    <div id="treeTypeDisplay" class="px-4 py-3 bg-blue-50 text-blue-800 font-medium border-b border-blue-100 flex items-center">
                        <i class="fas fa-info-circle mr-2"></i>
                        <span>Tree type will be detected after generation</span>
                    </div>
                    
                    <!-- Tabs for visualization modes -->
                    <div class="flex border-b border-gray-200 bg-gray-50 px-4">
                        <div id="visualizationTabBtn" class="tab px-4 py-3 text-sm font-medium active">
                            <i class="fas fa-project-diagram mr-1"></i> Visualization
                        </div>
                        <div id="animationTabBtn" class="tab px-4 py-3 text-sm font-medium">
                            <i class="fas fa-play-circle mr-1"></i> Traversal Animation
                        </div>
                        <div id="comparisonTabBtn" class="tab px-4 py-3 text-sm font-medium">
                            <i class="fas fa-exchange-alt mr-1"></i> Tree Comparison
                        </div>
                    </div>
                    
                    <!-- Graph visualization with controls -->
                    <div id="visualizationTab" class="p-4">
                        <div class="mb-3 flex justify-between">
                            <div class="flex items-center">
                                <button id="zoomInBtn" class="mr-1 p-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-all">
                                    <i class="fas fa-search-plus"></i>
                                </button>
                                <button id="zoomOutBtn" class="mr-1 p-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-all">
                                    <i class="fas fa-search-minus"></i>
                                </button>
                                <button id="resetZoomBtn" class="p-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded transition-all">
                                    <i class="fas fa-expand"></i>
                                </button>
                            </div>
                            <div class="flex items-center">
                                <select id="edgeStyle" class="mr-2 p-1 text-sm border border-gray-300 rounded bg-white focus:ring-blue-500 focus:border-blue-500">
                                    <option value="straight">Straight edges</option>
                                    <option value="curved" selected>Curved edges</option>
                                    <option value="dynamic">Dynamic edges</option>
                                </select>
                                <div class="relative">
                                    <div id="nodeColorSelector" class="w-6 h-6 rounded-full bg-blue-500 cursor-pointer border border-gray-300"></div>
                                </div>
                            </div>
                        </div>
                        <div id="network" class="mb-4"></div>
                    </div>
                    
                    <!-- Animation tab content (hidden initially) -->
                    <div id="animationTab" class="p-4 hidden">
                        <div class="mb-4 flex items-center space-x-2">
                            <select id="traversalType" class="p-2 text-sm border border-gray-300 rounded bg-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="preOrder">Pre-order Traversal</option>
                                <option value="inOrder">In-order Traversal</option>
                                <option value="postOrder">Post-order Traversal</option>
                                <option value="levelOrder">Level-order Traversal</option>
                            </select>
                            <button id="startAnimationBtn" class="flex items-center justify-center px-3 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all">
                                <i class="fas fa-play mr-1"></i> Play
                            </button>
                            <button id="pauseAnimationBtn" disabled class="flex items-center justify-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                                <i class="fas fa-pause mr-1"></i> Pause
                            </button>
                            <button id="stopAnimationBtn" disabled class="flex items-center justify-center px-3 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                                <i class="fas fa-stop mr-1"></i> Stop
                            </button>
                            <div class="flex items-center">
                                <label class="text-sm text-gray-700 mr-2">Speed:</label>
                                <input type="range" id="animationSpeed" min="1" max="10" value="5" class="w-24">
                            </div>
                        </div>
                        <div id="animationNetwork" class="h-80 border border-gray-200 rounded bg-white"></div>
                        <div id="animationSteps" class="mt-3 text-sm bg-gray-50 p-3 rounded border border-gray-200 h-24 overflow-y-auto">
                            Animation steps will appear here...
                        </div>
                    </div>
                    
                    <!-- Comparison tab content (hidden initially) -->
                    <div id="comparisonTab" class="p-4 hidden">
                        <div class="mb-3 grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Tree 1</label>
                                <input type="text" id="compareTree1" class="w-full p-2 border border-gray-300 rounded-md" value="1,2,3,4,5">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Tree 2</label>
                                <input type="text" id="compareTree2" class="w-full p-2 border border-gray-300 rounded-md" value="1,2,3,5,4">
                            </div>
                        </div>
                        <button id="compareTreesBtn" class="mb-3 w-full flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                            <i class="fas fa-exchange-alt mr-1"></i> Compare Trees
                        </button>
                        <div class="grid grid-cols-2 gap-4">
                            <div id="compareNetwork1" class="h-64 border border-gray-200 rounded bg-white"></div>
                            <div id="compareNetwork2" class="h-64 border border-gray-200 rounded bg-white"></div>
                        </div>
                        <div id="comparisonResults" class="mt-3 text-sm bg-gray-50 p-3 rounded border border-gray-200">
                            Comparison results will appear here...
                        </div>
                    </div>
                </div>
                
                <!-- Analysis results and traversals -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Traversal results card with improved styling -->
                    <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden">
                        <div class="px-4 py-3 border-b border-gray-200 bg-gray-50 flex justify-between items-center">
                            <h3 class="text-lg font-medium text-gray-900 flex items-center">
                                <i class="fas fa-route text-blue-500 mr-2"></i>
                                Traversals
                            </h3>
                            <button id="copyTraversalsBtn" class="p-1 text-gray-500 hover:text-gray-700 rounded" title="Copy to clipboard">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <div id="traversalResults" class="p-4 space-y-3">
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-sm font-medium text-gray-700 mb-1 flex items-center">
                                    <i class="fas fa-arrow-right text-green-500 mr-1"></i> Pre-order
                                </div>
                                <div id="preOrderResult" class="text-sm font-mono bg-white p-2 rounded border border-gray-200"></div>
                            </div>
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-sm font-medium text-gray-700 mb-1 flex items-center">
                                    <i class="fas fa-arrows-alt-h text-blue-500 mr-1"></i> In-order
                                </div>
                                <div id="inOrderResult" class="text-sm font-mono bg-white p-2 rounded border border-gray-200"></div>
                            </div>
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-sm font-medium text-gray-700 mb-1 flex items-center">
                                    <i class="fas fa-arrow-left text-purple-500 mr-1"></i> Post-order
                                </div>
                                <div id="postOrderResult" class="text-sm font-mono bg-white p-2 rounded border border-gray-200"></div>
                            </div>
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-sm font-medium text-gray-700 mb-1 flex items-center">
                                    <i class="fas fa-level-down-alt text-orange-500 mr-1"></i> Level-order
                                </div>
                                <div id="levelOrderResult" class="text-sm font-mono bg-white p-2 rounded border border-gray-200"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Analysis results card with improved styling -->
                    <div class="bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden">
                        <div class="px-4 py-3 border-b border-gray-200 bg-gray-50 flex justify-between items-center">
                            <h3 class="text-lg font-medium text-gray-900 flex items-center">
                                <i class="fas fa-chart-bar text-blue-500 mr-2"></i>
                                Analysis
                            </h3>
                            <div>
                                <button id="copyAnalysisBtn" class="p-1 text-gray-500 hover:text-gray-700 rounded mr-1" title="Copy to clipboard">
                                    <i class="fas fa-copy"></i>
                                </button>
                                <button id="expandAnalysisBtn" class="p-1 text-gray-500 hover:text-gray-700 rounded" title="Show more details">
                                    <i class="fas fa-expand-alt"></i>
                                </button>
                            </div>
                        </div>
                        <div id="analysisResults" class="p-4 space-y-3">
                            <div class="grid grid-cols-2 gap-3">
                                <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                    <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Height</div>
                                    <div id="treeHeight" class="text-lg font-semibold text-gray-800">-</div>
                                </div>
                                <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                    <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Node Count</div>
                                    <div id="nodeCount" class="text-lg font-semibold text-gray-800">-</div>
                                </div>
                                <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                    <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Leaf Nodes</div>
                                    <div id="leafNodes" class="text-lg font-semibold text-gray-800">-</div>
                                </div>
                                <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                    <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Balance Factor</div>
                                    <div id="balanceFactor" class="text-lg font-semibold text-gray-800">-</div>
                                </div>
                            </div>
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Properties</div>
                                <div id="treeProperties" class="text-sm">Tree properties will appear here...</div>
                            </div>
                            <div class="rounded bg-gray-50 p-3 border border-gray-200">
                                <div class="text-xs text-gray-500 uppercase tracking-wider mb-1">Special Features</div>
                                <div id="specialFeatures" class="text-sm">Special features will appear here...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Advanced features accordion card -->
                <div class="mt-6 bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden">
                    <div class="px-4 py-3 border-b border-gray-200 bg-gray-50 flex justify-between items-center cursor-pointer" id="advancedToggle">
                        <h3 class="text-lg font-medium text-gray-900 flex items-center">
                            <i class="fas fa-rocket text-blue-500 mr-2"></i>
                            Advanced Features
                        </h3>
                        <button class="p-1 text-gray-500 hover:text-gray-700 rounded">
                            <i class="fas fa-chevron-down" id="advancedChevron"></i>
                        </button>
                    </div>
                    <div id="advancedContent" class="hidden p-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Tree Operations</label>
                                <select id="treeOperation" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                                    <option value="serialize">Serialize Tree</option>
                                    <option value="deserialize">Deserialize Tree</option>
                                    <option value="mirror">Mirror Tree</option>
                                    <option value="subtree">Find Subtree</option>
                                    <option value="lca">Lowest Common Ancestor</option>
                                    <option value="path">Path Between Nodes</option>
                                    <option value="serialize">Convert to Linked List</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Operation Parameters</label>
                                <div class="flex space-x-2">
                                    <input type="text" id="operationParams" class="flex-1 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Parameters (if needed)">
                                    <button id="executeOperationBtn" class="flex items-center justify-center px-3 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all">
                                        <i class="fas fa-play mr-1"></i> Execute
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                            <h4 class="text-sm font-medium text-gray-700 mb-2">Operation Result</h4>
                            <div id="operationResult" class="bg-white p-3 rounded border border-gray-200 text-sm font-mono overflow-x-auto max-h-32">
                                Operation results will appear here...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer with improved styling -->
    <footer class="bg-white border-t border-gray-200 mt-8">
        <div class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="flex items-center mb-4 md:mb-0">
                    <span class="text-sm text-gray-500">Advanced Tree Traversal Calculator</span>
                    <span class="mx-2 text-gray-300">|</span>
                    <span class="text-sm text-gray-500">Version 2.0</span>
                </div>
                <div class="flex space-x-4">
                    <a href="#" class="text-gray-400 hover:text-gray-600 transition-all">
                        <i class="fab fa-github"></i>
                    </a>
                    <a href="#" class="text-gray-400 hover:text-gray-600 transition-all">
                        <i class="fas fa-question-circle"></i>
                    </a>
                    <a href="#" class="text-gray-400 hover:text-gray-600 transition-all">
                        <i class="fas fa-envelope"></i>
                    </a>
                </div>
            </div>
        </div>
    </footer>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content w-full max-w-2xl">
            <div class="flex justify-between items-center border-b border-gray-200 pb-3 mb-4">
                <h3 class="text-lg font-medium text-gray-900">How to Use This Tool</h3>
                <button class="close-modal text-gray-400 hover:text-gray-500 focus:outline-none">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-4 max-h-96 overflow-y-auto pr-2">
                <div>
                    <h4 class="font-medium text-gray-800 mb-1">Creating a Tree</h4>
                    <p class="text-sm text-gray-600">You can create a tree in three ways:</p>
                    <ul class="list-disc pl-5 mt-2 text-sm text-gray-600">
                        <li><strong>Text Input:</strong> Enter values separated by commas. For binary trees, use 'null' for empty nodes.</li>
                        <li><strong>JSON Input:</strong> Use the format {"value": x, "left": {...}, "right": {...}}</li>
                        <li><strong>Visual Input:</strong> Draw your tree by adding nodes and connections visually.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 mb-1">Analyzing Your Tree</h4>
                    <p class="text-sm text-gray-600">After generating your tree, you can:</p>
                    <ul class="list-disc pl-5 mt-2 text-sm text-gray-600">
                        <li>View different tree traversals (pre-order, in-order, post-order, level-order)</li>
                        <li>Analyze tree properties (height, node count, balance factor)</li>
                        <li>Check if your tree is a Binary Search Tree, Complete, Full, or Perfect</li>
                        <li>Animate traversals to understand the algorithms better</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 mb-1">Advanced Features</h4>
                    <p class="text-sm text-gray-600">The advanced features section allows you to:</p>
                    <ul class="list-disc pl-5 mt-2 text-sm text-gray-600">
                        <li>Serialize and deserialize trees</li>
                        <li>Find the lowest common ancestor of two nodes</li>
                        <li>Find the path between nodes</li>
                        <li>Mirror your tree structure</li>
                        <li>Compare two different trees</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 mb-1">Keyboard Shortcuts</h4>
                    <div class="grid grid-cols-2 gap-2 mt-2">
                        <div class="text-sm"><span class="font-mono bg-gray-100 px-1 py-0.5 rounded">Ctrl + G</span> Generate Tree</div>
                        <div class="text-sm"><span class="font-mono bg-gray-100 px-1 py-0.5 rounded">Ctrl + A</span> Analyze Tree</div>
                        <div class="text-sm"><span class="font-mono bg-gray-100 px-1 py-0.5 rounded">Ctrl + S</span> Save Tree</div>
                        <div class="text-sm"><span class="font-mono bg-gray-100 px-1 py-0.5 rounded">Ctrl + O</span> Open Tree</div>
                    </div>
                </div>
            </div>
            <div class="mt-5 border-t border-gray-200 pt-4">
                <button class="close-modal w-full flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                    Got it!
                </button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content w-full max-w-md">
            <div class="flex justify-between items-center border-b border-gray-200 pb-3 mb-4">
                <h3 class="text-lg font-medium text-gray-900">Settings</h3>
                <button class="close-modal text-gray-400 hover:text-gray-500 focus:outline-none">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="flex items-center justify-between">
                        <span class="text-sm font-medium text-gray-700">Dark Mode</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none">
                            <input type="checkbox" id="darkModeToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" />
                            <label for="darkModeToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                        </div>
                    </label>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Default Edge Style</label>
                    <select id="defaultEdgeStyle" class="w-full p-2 border border-gray-300 rounded-md">
                        <option value="straight">Straight</option>
                        <option value="curved" selected>Curved</option>
                        <option value="dynamic">Dynamic</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Animation Speed</label>
                    <input type="range" id="defaultAnimationSpeed" min="1" max="10" value="5" class="w-full">
                    <div class="flex justify-between text-xs text-gray-500">
                        <span>Slow</span>
                        <span>Fast</span>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Node Color</label>
                    <div class="grid grid-cols-6 gap-2">
                        <div class="w-8 h-8 rounded-full bg-blue-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-blue-500 color-option" data-color="#3B82F6"></div>
                        <div class="w-8 h-8 rounded-full bg-green-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-green-500 color-option" data-color="#10B981"></div>
                        <div class="w-8 h-8 rounded-full bg-red-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-red-500 color-option" data-color="#EF4444"></div>
                        <div class="w-8 h-8 rounded-full bg-purple-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-purple-500 color-option" data-color="#8B5CF6"></div>
                        <div class="w-8 h-8 rounded-full bg-yellow-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-yellow-500 color-option" data-color="#F59E0B"></div>
                        <div class="w-8 h-8 rounded-full bg-pink-500 cursor-pointer hover:ring-2 hover:ring-offset-2 hover:ring-pink-500 color-option" data-color="#EC4899"></div>
                    </div>
                </div>
            </div>
            <div class="mt-5 border-t border-gray-200 pt-4 flex justify-between">
                <button class="close-modal flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                    Cancel
                </button>
                <button id="saveSettingsBtn" class="flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                    Save Settings
                </button>
            </div>
        </div>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="toast">This is a notification</div>

    <!-- Analysis detail modal -->
    <div id="analysisDetailModal" class="modal">
        <div class="modal-content w-full max-w-3xl">
            <div class="flex justify-between items-center border-b border-gray-200 pb-3 mb-4">
                <h3 class="text-lg font-medium text-gray-900">Detailed Tree Analysis</h3>
                <button class="close-modal text-gray-400 hover:text-gray-500 focus:outline-none">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-4 max-h-96 overflow-y-auto pr-2">
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                    <h4 class="font-medium text-gray-800 mb-2">Tree Structure</h4>
                    <div id="detailedStructure" class="text-sm font-mono bg-white p-3 rounded border border-gray-200 overflow-x-auto"></div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                        <h4 class="font-medium text-gray-800 mb-2">Basic Metrics</h4>
                        <ul class="space-y-2 text-sm" id="detailedMetrics"></ul>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                        <h4 class="font-medium text-gray-800 mb-2">Tree Properties</h4>
                        <ul class="space-y-2 text-sm" id="detailedProperties"></ul>
                    </div>
                </div>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                    <h4 class="font-medium text-gray-800 mb-2">Node Analysis</h4>
                    <table class="w-full text-sm">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="p-2 text-left">Node</th>
                                <th class="p-2 text-left">Depth</th>
                                <th class="p-2 text-left">Height</th>
                                <th class="p-2 text-left">Children</th>
                                <th class="p-2 text-left">Type</th>
                            </tr>
                        </thead>
                        <tbody id="nodeAnalysisTable" class="bg-white"></tbody>
                    </table>
                </div>
                <div class="bg-gray-50 p-4 rounded-md border border-gray-200">
                    <h4 class="font-medium text-gray-800 mb-2">Algorithm Complexity</h4>
                    <table class="w-full text-sm">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="p-2 text-left">Operation</th>
                                <th class="p-2 text-left">Time Complexity</th>
                                <th class="p-2 text-left">Space Complexity</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white">
                            <tr>
                                <td class="p-2 border-t border-gray-200">Search</td>
                                <td id="searchTimeComplexity" class="p-2 border-t border-gray-200"></td>
                                <td id="searchSpaceComplexity" class="p-2 border-t border-gray-200"></td>
                            </tr>
                            <tr>
                                <td class="p-2 border-t border-gray-200">Insert</td>
                                <td id="insertTimeComplexity" class="p-2 border-t border-gray-200"></td>
                                <td id="insertSpaceComplexity" class="p-2 border-t border-gray-200"></td>
                            </tr>
                            <tr>
                                <td class="p-2 border-t border-gray-200">Delete</td>
                                <td id="deleteTimeComplexity" class="p-2 border-t border-gray-200"></td>
                                <td id="deleteSpaceComplexity" class="p-2 border-t border-gray-200"></td>
                            </tr>
                            <tr>
                                <td class="p-2 border-t border-gray-200">Traversal</td>
                                <td id="traversalTimeComplexity" class="p-2 border-t border-gray-200"></td>
                                <td id="traversalSpaceComplexity" class="p-2 border-t border-gray-200"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="mt-5 border-t border-gray-200 pt-4 flex justify-end">
                <button id="downloadAnalysisBtn" class="flex items-center justify-center px-4 py-2 mr-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                    <i class="fas fa-download mr-1"></i> Download Report
                </button>
                <button class="close-modal flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- JS script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global variables
            let network = null;
            let animationNetwork = null;
            let compareNetwork1 = null;
            let compareNetwork2 = null;
            let nodes = new vis.DataSet();
            let edges = new vis.DataSet();
            let currentNodeId = 0;
            let animationInterval = null;
            let currentAnimationStep = 0;
            let animationSteps = [];
            let selectedNodes = [];
            let networkData = { nodes: nodes, edges: edges };
            let treeRoot = null;
            let darkModeEnabled = false;
            
            // Tree node class
            class TreeNode {
                constructor(value) {
                    this.value = value;
                    this.left = null;
                    this.right = null;
                }
            }
            
            // Initialize the network visualization
            function initNetwork() {
                const container = document.getElementById('network');
                const options = {
                    layout: {
                        hierarchical: {
                            direction: 'UD',
                            sortMethod: 'directed',
                            nodeSpacing: 100,
                            levelSeparation: 150
                        }
                    },
                    physics: false,
                    interaction: {
                        dragNodes: true,
                        dragView: true,
                        zoomView: true
                    },
                    nodes: {
                        shape: 'circle',
                        size: 30,
                        font: {
                            size: 16,
                            color: '#ffffff'
                        },
                        borderWidth: 2,
                        shadow: true
                    },
                    edges: {
                        width: 2,
                        shadow: true,
                        smooth: {
                            type: 'curvedCW',
                            roundness: 0.2
                        }
                    }
                };
                
                network = new vis.Network(container, networkData, options);
                
                // Setup animation network
                const animationContainer = document.getElementById('animationNetwork');
                animationNetwork = new vis.Network(animationContainer, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
                
                // Setup comparison networks
                const compareContainer1 = document.getElementById('compareNetwork1');
                const compareContainer2 = document.getElementById('compareNetwork2');
                compareNetwork1 = new vis.Network(compareContainer1, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
                compareNetwork2 = new vis.Network(compareContainer2, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
                
                // Network events
                network.on('doubleClick', function(params) {
                    if (params.nodes.length === 0) {
                        // Add node at click position
                        const value = prompt('Enter node value:', '');
                        if (value !== null && value.trim() !== '') {
                            const nodeId = ++currentNodeId;
                            const position = network.DOMtoCanvas(params.pointer.DOM);
                            nodes.add({
                                id: nodeId,
                                label: value,
                                x: position.x,
                                y: position.y,
                                color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                            });
                        }
                    }
                });
                
                network.on('click', function(params) {
                    if (params.nodes.length === 1) {
                        const nodeId = params.nodes[0];
                        
                        // If no nodes selected yet or starting new selection
                        if (selectedNodes.length === 0 || (selectedNodes.length === 1 && selectedNodes[0] === nodeId)) {
                            selectedNodes = [nodeId];
                            nodes.update({ id: nodeId, color: { background: '#F59E0B' } });
                            showToast('Node selected. Click another node to create an edge.', 'info');
                        } 
                        // If one node already selected, create edge
                        else if (selectedNodes.length === 1) {
                            const fromId = selectedNodes[0];
                            const toId = nodeId;
                            
                            // Check if edge already exists
                            const existingEdges = edges.get({
                                filter: function(edge) {
                                    return (edge.from === fromId && edge.to === toId) || 
                                           (edge.from === toId && edge.to === fromId);
                                }
                            });
                            
                            if (existingEdges.length === 0) {
                                edges.add({ from: fromId, to: toId });
                                showToast('Edge created!', 'success');
                            } else {
                                showToast('Edge already exists!', 'error');
                            }
                            
                            // Reset node colors and selection
                            nodes.update({ id: selectedNodes[0], color: { background: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6' } });
                            selectedNodes = [];
                        }
                    }
                });
            }
            
            // Create tree from array (level order)
            function createTreeFromArray(arr) {
                if (!arr || arr.length === 0) return null;
                
                // Clean up the array - handle strings and null values
                const cleanArr = arr.map(val => {
                    if (val === 'null' || val === null || val === undefined || val === '') {
                        return null;
                    }
                    return isNaN(val) ? val : Number(val);
                });
                
                const root = new TreeNode(cleanArr[0]);
                const queue = [root];
                let i = 1;
                
                while (queue.length > 0 && i < cleanArr.length) {
                    const node = queue.shift();
                    
                    // Add left child
                    if (i < cleanArr.length && cleanArr[i] !== null) {
                        node.left = new TreeNode(cleanArr[i]);
                        queue.push(node.left);
                    }
                    i++;
                    
                    // Add right child
                    if (i < cleanArr.length && cleanArr[i] !== null) {
                        node.right = new TreeNode(cleanArr[i]);
                        queue.push(node.right);
                    }
                    i++;
                }
                
                return root;
            }
            
            // Create tree from JSON
            function createTreeFromJson(json) {
                if (!json) return null;
                
                try {
                    const data = typeof json === 'string' ? JSON.parse(json) : json;
                    
                    function buildTree(node) {
                        if (!node) return null;
                        
                        const root = new TreeNode(node.value);
                        
                        if (node.left) {
                            root.left = buildTree(node.left);
                        }
                        
                        if (node.right) {
                            root.right = buildTree(node.right);
                        }
                        
                        return root;
                    }
                    
                    return buildTree(data);
                } catch (e) {
                    showToast('Invalid JSON format!', 'error');
                    console.error(e);
                    return null;
                }
            }
            
            // Generate network from tree
            function visualizeTree(root) {
                nodes.clear();
                edges.clear();
                currentNodeId = 0;
                
                if (!root) {
                    showToast('No valid tree to visualize!', 'error');
                    return;
                }
                
                function addTreeToNetwork(node, parentId = null, level = 0) {
                    if (!node) return null;
                    
                    currentNodeId++;
                    const nodeId = currentNodeId;
                    
                    nodes.add({
                        id: nodeId,
                        label: node.value.toString(),
                        level: level,
                        color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                    });
                    
                    if (parentId !== null) {
                        edges.add({ from: parentId, to: nodeId });
                    }
                    
                    if (node.left) {
                        addTreeToNetwork(node.left, nodeId, level + 1);
                    }
                    
                    if (node.right) {
                        addTreeToNetwork(node.right, nodeId, level + 1);
                    }
                    
                    return nodeId;
                }
                
                addTreeToNetwork(root);
                network.fit();
            }
            
            // Set edge style based on select box
            function updateEdgeStyle() {
                const style = document.getElementById('edgeStyle').value;
                let smooth = {};
                
                switch (style) {
                    case 'straight':
                        smooth = { enabled: false };
                        break;
                    case 'curved':
                        smooth = { type: 'curvedCW', roundness: 0.2 };
                        break;
                    case 'dynamic':
                        smooth = { type: 'dynamic', roundness: 0.5 };
                        break;
                }
                
                edges.forEach(edge => {
                    edges.update({ id: edge.id, smooth: smooth });
                });
            }
            
            // Tree traversal functions
            function preOrderTraversal(node, result = []) {
                if (!node) return result;
                
                result.push(node.value);
                preOrderTraversal(node.left, result);
                preOrderTraversal(node.right, result);
                
                return result;
            }
            
            function inOrderTraversal(node, result = []) {
                if (!node) return result;
                
                inOrderTraversal(node.left, result);
                result.push(node.value);
                inOrderTraversal(node.right, result);
                
                return result;
            }
            
            function postOrderTraversal(node, result = []) {
                if (!node) return result;
                
                postOrderTraversal(node.left, result);
                postOrderTraversal(node.right, result);
                result.push(node.value);
                
                return result;
            }
            
            function levelOrderTraversal(root) {
                if (!root) return [];
                
                const result = [];
                const queue = [root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node.value);
                    
                    if (node.left) queue.push(node.left);
                    if (node.right) queue.push(node.right);
                }
                
                return result;
            }
            
            // Display traversal results
            function displayTraversals(root) {
                if (!root) {
                    document.getElementById('preOrderResult').textContent = '[]';
                    document.getElementById('inOrderResult').textContent = '[]';
                    document.getElementById('postOrderResult').textContent = '[]';
                    document.getElementById('levelOrderResult').textContent = '[]';
                    return;
                }
                
                document.getElementById('preOrderResult').textContent = JSON.stringify(preOrderTraversal(root));
                document.getElementById('inOrderResult').textContent = JSON.stringify(inOrderTraversal(root));
                document.getElementById('postOrderResult').textContent = JSON.stringify(postOrderTraversal(root));
                document.getElementById('levelOrderResult').textContent = JSON.stringify(levelOrderTraversal(root));
            }
            
            // Tree analysis functions
            function analyzeTree(root) {
                if (!root) {
                    resetAnalysisFields();
                    return;
                }
                
                // Calculate height
                function calculateHeight(node) {
                    if (!node) return -1;
                    return Math.max(calculateHeight(node.left), calculateHeight(node.right)) + 1;
                }
                
                // Calculate node count
                function calculateNodeCount(node) {
                    if (!node) return 0;
                    return calculateNodeCount(node.left) + calculateNodeCount(node.right) + 1;
                }
                
                // Get leaf nodes
                function getLeafNodes(node, leaves = []) {
                    if (!node) return leaves;
                    
                    if (!node.left && !node.right) {
                        leaves.push(node.value);
                    }
                    
                    getLeafNodes(node.left, leaves);
                    getLeafNodes(node.right, leaves);
                    
                    return leaves;
                }
                
                // Check if BST
                function isBST(node, min = -Infinity, max = Infinity) {
                    if (!node) return true;
                    
                    if (node.value <= min || node.value >= max) {
                        return false;
                    }
                    
                    return isBST(node.left, min, node.value) && isBST(node.right, node.value, max);
                }
                
                // Check if balanced
                function isBalanced(node) {
                    function checkHeight(n) {
                        if (!n) return 0;
                        
                        const leftHeight = checkHeight(n.left);
                        if (leftHeight === -1) return -1;
                        
                        const rightHeight = checkHeight(n.right);
                        if (rightHeight === -1) return -1;
                        
                        if (Math.abs(leftHeight - rightHeight) > 1) return -1;
                        
                        return Math.max(leftHeight, rightHeight) + 1;
                    }
                    
                    return checkHeight(node) !== -1;
                }
                
                // Check if complete
                function isComplete(node) {
                    if (!node) return true;
                    
                    const nodeCount = calculateNodeCount(node);
                    
                    // Check if number of nodes is 2^h - 1 (where h is height)
                    const height = calculateHeight(node);
                    return nodeCount === Math.pow(2, height + 1) - 1;
                }
                
                // Check if full binary tree (every node has 0 or 2 children)
                function isFull(node) {
                    if (!node) return true;
                    
                    if (!node.left && !node.right) return true;
                    
                    if (node.left && node.right) {
                        return isFull(node.left) && isFull(node.right);
                    }
                    
                    return false;
                }
                
                // Check if perfect binary tree
                function isPerfect(node) {
                    return isComplete(node) && isFull(node);
                }
                
                const height = calculateHeight(root);
                const nodeCount = calculateNodeCount(root);
                const leafNodes = getLeafNodes(root);
                const balanced = isBalanced(root);
                const bst = isBST(root);
                const complete = isComplete(root);
                const full = isFull(root);
                const perfect = isPerfect(root);
                
                // Balance factor
                function calculateBalanceFactor(node) {
                    if (!node) return 0;
                    
                    return calculateHeight(node.left) - calculateHeight(node.right);
                }
                
                const balanceFactor = calculateBalanceFactor(root);
                
                // Update UI
                document.getElementById('treeHeight').textContent = height;
                document.getElementById('nodeCount').textContent = nodeCount;
                document.getElementById('leafNodes').textContent = leafNodes.length;
                document.getElementById('balanceFactor').textContent = balanceFactor;
                
                let properties = '';
                properties += `Binary Search Tree: ${bst ? 'Yes' : 'No'}<br>`;
                properties += `Balanced: ${balanced ? 'Yes' : 'No'}<br>`;
                properties += `Complete: ${complete ? 'Yes' : 'No'}<br>`;
                properties += `Full: ${full ? 'Yes' : 'No'}<br>`;
                properties += `Perfect: ${perfect ? 'Yes' : 'No'}`;
                
                document.getElementById('treeProperties').innerHTML = properties;
                
                // Determine tree type
                let treeType = '';
                if (perfect) {
                    treeType = 'Perfect Binary Tree';
                } else if (complete) {
                    treeType = 'Complete Binary Tree';
                } else if (full) {
                    treeType = 'Full Binary Tree';
                } else if (bst) {
                    treeType = 'Binary Search Tree';
                } else if (balanced) {
                    treeType = 'Balanced Binary Tree';
                } else {
                    treeType = 'Binary Tree';
                }
                
                document.getElementById('treeTypeDisplay').innerHTML = `<i class="fas fa-info-circle mr-2"></i><span>Tree Type: ${treeType}</span>`;
                
                // Special features
                let features = '';
                if (height > 10) {
                    features += 'Deep tree structure (height > 10)<br>';
                }
                if (leafNodes.length > nodeCount/2) {
                    features += 'High leaf node ratio<br>';
                }
                if (Math.abs(balanceFactor) > 1) {
                    features += 'Unbalanced tree (may need rotation)<br>';
                }
                if (bst && !balanced) {
                    features += 'Unbalanced BST (consider AVL/Red-Black conversion)';
                }
                
                document.getElementById('specialFeatures').innerHTML = features || 'No special features detected';
                
                // Set up detailed analysis
                populateDetailedAnalysis(root);
                
                // Set complexity info
                updateComplexityInfo(bst, balanced, complete);
            }
            
            function resetAnalysisFields() {
                document.getElementById('treeHeight').textContent = '-';
                document.getElementById('nodeCount').textContent = '-';
                document.getElementById('leafNodes').textContent = '-';
                document.getElementById('balanceFactor').textContent = '-';
                document.getElementById('treeProperties').innerHTML = 'Tree properties will appear here...';
                document.getElementById('specialFeatures').innerHTML = 'Special features will appear here...';
                document.getElementById('treeTypeDisplay').innerHTML = '<i class="fas fa-info-circle mr-2"></i><span>Tree type will be detected after generation</span>';
            }
            
            function populateDetailedAnalysis(root) {
                if (!root) return;
                
                // Generate structure representation
                document.getElementById('detailedStructure').textContent = JSON.stringify(treeToJson(root), null, 2);
                
                // Calculate metrics
                function calculateHeight(node) {
                    if (!node) return -1;
                    return Math.max(calculateHeight(node.left), calculateHeight(node.right)) + 1;
                }
                
                function calculateNodeCount(node) {
                    if (!node) return 0;
                    return calculateNodeCount(node.left) + calculateNodeCount(node.right) + 1;
                }
                
                function getDepth(node, target, depth = 0) {
                    if (!node) return -1;
                    if (node === target) return depth;
                    
                    const leftDepth = getDepth(node.left, target, depth + 1);
                    if (leftDepth !== -1) return leftDepth;
                    
                    return getDepth(node.right, target, depth + 1);
                }
                
                const height = calculateHeight(root);
                const nodeCount = calculateNodeCount(root);
                const internalNodes = nodeCount - document.getElementById('leafNodes').textContent;
                const maxLeaves = Math.pow(2, height);
                const actualLeaves = document.getElementById('leafNodes').textContent;
                
                // Build metrics list
                let metricsHtml = '';
                metricsHtml += `<li><span class="font-medium">Height:</span> ${height}</li>`;
                metricsHtml += `<li><span class="font-medium">Total Nodes:</span> ${nodeCount}</li>`;
                metricsHtml += `<li><span class="font-medium">Internal Nodes:</span> ${internalNodes}</li>`;
                metricsHtml += `<li><span class="font-medium">Leaf Nodes:</span> ${actualLeaves}</li>`;
                metricsHtml += `<li><span class="font-medium">Max Possible Leaves:</span> ${maxLeaves}</li>`;
                metricsHtml += `<li><span class="font-medium">Leaf Efficiency:</span> ${Math.round((actualLeaves / maxLeaves) * 100)}%</li>`;
                
                document.getElementById('detailedMetrics').innerHTML = metricsHtml;
                
                // Build property analysis
                const isBST = document.getElementById('treeProperties').innerHTML.includes('Binary Search Tree: Yes');
                const isBalanced = document.getElementById('treeProperties').innerHTML.includes('Balanced: Yes');
                const isComplete = document.getElementById('treeProperties').innerHTML.includes('Complete: Yes');
                const isFull = document.getElementById('treeProperties').innerHTML.includes('Full: Yes');
                const isPerfect = document.getElementById('treeProperties').innerHTML.includes('Perfect: Yes');
                
                let propertiesHtml = '';
                propertiesHtml += `<li><span class="font-medium">Binary Search Tree:</span> ${isBST ? 'Yes' : 'No'}</li>`;
                propertiesHtml += `<li><span class="font-medium">Balanced:</span> ${isBalanced ? 'Yes' : 'No'}</li>`;
                propertiesHtml += `<li><span class="font-medium">Complete:</span> ${isComplete ? 'Yes' : 'No'}</li>`;
                propertiesHtml += `<li><span class="font-medium">Full:</span> ${isFull ? 'Yes' : 'No'}</li>`;
                propertiesHtml += `<li><span class="font-medium">Perfect:</span> ${isPerfect ? 'Yes' : 'No'}</li>`;
                
                document.getElementById('detailedProperties').innerHTML = propertiesHtml;
                
                // Node analysis table
                let nodeAnalysisHtml = '';
                
                function traverseForNodeAnalysis(node, depth = 0, parent = null) {
                    if (!node) return;
                    
                    const nodeHeight = calculateHeight(node);
                    const childrenCount = (node.left ? 1 : 0) + (node.right ? 1 : 0);
                    let nodeType = 'Internal';
                    
                    if (!parent) {
                        nodeType = 'Root';
                    } else if (childrenCount === 0) {
                        nodeType = 'Leaf';
                    }
                    
                    nodeAnalysisHtml += `<tr>
                        <td class="p-2 border-t border-gray-200">${node.value}</td>
                        <td class="p-2 border-t border-gray-200">${depth}</td>
                        <td class="p-2 border-t border-gray-200">${nodeHeight}</td>
                        <td class="p-2 border-t border-gray-200">${childrenCount}</td>
                        <td class="p-2 border-t border-gray-200">${nodeType}</td>
                    </tr>`;
                    
                    traverseForNodeAnalysis(node.left, depth + 1, node);
                    traverseForNodeAnalysis(node.right, depth + 1, node);
                }
                
                traverseForNodeAnalysis(root);
                document.getElementById('nodeAnalysisTable').innerHTML = nodeAnalysisHtml;
            }
            
            function updateComplexityInfo(isBST, isBalanced, isComplete) {
                // Time complexity
                let searchTime, insertTime, deleteTime, traversalTime;
                let searchSpace, insertSpace, deleteSpace, traversalSpace;
                
                if (isBST && isBalanced) {
                    searchTime = "O(log n)";
                    insertTime = "O(log n)";
                    deleteTime = "O(log n)";
                } else if (isBST) {
                    searchTime = "O(h) - worst case O(n)";
                    insertTime = "O(h) - worst case O(n)";
                    deleteTime = "O(h) - worst case O(n)";
                } else {
                    searchTime = "O(n)";
                    insertTime = "O(n)";
                    deleteTime = "O(n)";
                }
                
                traversalTime = "O(n)";
                
                // Space complexity
                searchSpace = "O(h) - worst case O(n)";
                insertSpace = "O(h) - worst case O(n)";
                deleteSpace = "O(h) - worst case O(n)";
                traversalSpace = "O(n)";
                
                document.getElementById('searchTimeComplexity').textContent = searchTime;
                document.getElementById('insertTimeComplexity').textContent = insertTime;
                document.getElementById('deleteTimeComplexity').textContent = deleteTime;
                document.getElementById('traversalTimeComplexity').textContent = traversalTime;
                
                document.getElementById('searchSpaceComplexity').textContent = searchSpace;
                document.getElementById('insertSpaceComplexity').textContent = insertSpace;
                document.getElementById('deleteSpaceComplexity').textContent = deleteSpace;
                document.getElementById('traversalSpaceComplexity').textContent = traversalSpace;
            }
            
            // Convert tree to JSON for visualization
            function treeToJson(node) {
                if (!node) return null;
                
                return {
                    value: node.value,
                    left: treeToJson(node.left),
                    right: treeToJson(node.right)
                };
            }
            
            // Tree animation functions
            function setupAnimationTraversal() {
                if (!treeRoot) {
                    showToast('No valid tree to animate!', 'error');
                    return;
                }
                
                const traversalType = document.getElementById('traversalType').value;
                const animationSpeed = 11 - document.getElementById('animationSpeed').value;
                
                // Set up animation network
                const animationNodes = new vis.DataSet();
                const animationEdges = new vis.DataSet();
                
                // Clone the main network
                nodes.forEach(node => {
                    animationNodes.add({
                        id: node.id,
                        label: node.label,
                        level: node.level,
                        color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                    });
                });
                
                edges.forEach(edge => {
                    animationEdges.add({ from: edge.from, to: edge.to });
                });
                
                animationNetwork.setData({ nodes: animationNodes, edges: animationEdges });
                animationSteps = [];
                
                // Generate animation steps
                switch (traversalType) {
                    case 'preOrder':
                        generatePreOrderSteps(treeRoot);
                        break;
                    case 'inOrder':
                        generateInOrderSteps(treeRoot);
                        break;
                    case 'postOrder':
                        generatePostOrderSteps(treeRoot);
                        break;
                    case 'levelOrder':
                        generateLevelOrderSteps(treeRoot);
                        break;
                }
                
                // Prepare animation controls
                document.getElementById('startAnimationBtn').disabled = false;
                document.getElementById('pauseAnimationBtn').disabled = true;
                document.getElementById('stopAnimationBtn').disabled = true;
                
                // Reset animation display
                document.getElementById('animationSteps').innerHTML = `<div class="text-gray-500">Ready to animate ${traversalType} traversal. Click Play to start.</div>`;
                currentAnimationStep = 0;
            }
            
            function generatePreOrderSteps(node, nodeMapping = buildNodeIdMapping()) {
                if (!node) return;
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'visit',
                    description: `Visit node ${node.value}`
                });
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'process',
                    description: `Process node ${node.value}`
                });
                
                if (node.left) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goLeft',
                        description: `Go to left child of ${node.value}`
                    });
                    generatePreOrderSteps(node.left, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromLeft',
                        description: `Return to node ${node.value} from left subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noLeft',
                        description: `Node ${node.value} has no left child`
                    });
                }
                
                if (node.right) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goRight',
                        description: `Go to right child of ${node.value}`
                    });
                    generatePreOrderSteps(node.right, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromRight',
                        description: `Return to node ${node.value} from right subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noRight',
                        description: `Node ${node.value} has no right child`
                    });
                }
            }
            
            function generateInOrderSteps(node, nodeMapping = buildNodeIdMapping()) {
                if (!node) return;
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'visit',
                    description: `Visit node ${node.value}`
                });
                
                if (node.left) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goLeft',
                        description: `Go to left child of ${node.value}`
                    });
                    generateInOrderSteps(node.left, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromLeft',
                        description: `Return to node ${node.value} from left subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noLeft',
                        description: `Node ${node.value} has no left child`
                    });
                }
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'process',
                    description: `Process node ${node.value}`
                });
                
                if (node.right) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goRight',
                        description: `Go to right child of ${node.value}`
                    });
                    generateInOrderSteps(node.right, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromRight',
                        description: `Return to node ${node.value} from right subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noRight',
                        description: `Node ${node.value} has no right child`
                    });
                }
            }
            
            function generatePostOrderSteps(node, nodeMapping = buildNodeIdMapping()) {
                if (!node) return;
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'visit',
                    description: `Visit node ${node.value}`
                });
                
                if (node.left) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goLeft',
                        description: `Go to left child of ${node.value}`
                    });
                    generatePostOrderSteps(node.left, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromLeft',
                        description: `Return to node ${node.value} from left subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noLeft',
                        description: `Node ${node.value} has no left child`
                    });
                }
                
                if (node.right) {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'goRight',
                        description: `Go to right child of ${node.value}`
                    });
                    generatePostOrderSteps(node.right, nodeMapping);
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'returnFromRight',
                        description: `Return to node ${node.value} from right subtree`
                    });
                } else {
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'noRight',
                        description: `Node ${node.value} has no right child`
                    });
                }
                
                animationSteps.push({
                    node: nodeMapping.get(node),
                    action: 'process',
                    description: `Process node ${node.value}`
                });
            }
            
            function generateLevelOrderSteps(root, nodeMapping = buildNodeIdMapping()) {
                if (!root) return;
                
                const queue = [root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'visit',
                        description: `Visit node ${node.value}`
                    });
                    
                    animationSteps.push({
                        node: nodeMapping.get(node),
                        action: 'process',
                        description: `Process node ${node.value}`
                    });
                    
                    if (node.left) {
                        animationSteps.push({
                            node: nodeMapping.get(node),
                            action: 'checkLeft',
                            description: `Check left child of ${node.value}`
                        });
                        queue.push(node.left);
                    } else {
                        animationSteps.push({
                            node: nodeMapping.get(node),
                            action: 'noLeft',
                            description: `Node ${node.value} has no left child`
                        });
                    }
                    
                    if (node.right) {
                        animationSteps.push({
                            node: nodeMapping.get(node),
                            action: 'checkRight',
                            description: `Check right child of ${node.value}`
                        });
                        queue.push(node.right);
                    } else {
                        animationSteps.push({
                            node: nodeMapping.get(node),
                            action: 'noRight',
                            description: `Node ${node.value} has no right child`
                        });
                    }
                }
            }
            
            // Helper to map tree nodes to network node IDs
            function buildNodeIdMapping() {
                const mapping = new Map();
                let nodeId = 1; // Assuming network nodes start from ID 1
                
                function mapNodes(node) {
                    if (!node) return;
                    
                    mapping.set(node, nodeId++);
                    mapNodes(node.left);
                    mapNodes(node.right);
                }
                
                mapNodes(treeRoot);
                return mapping;
            }
            
            // Start the animation
            function startAnimation() {
                if (animationInterval) {
                    clearInterval(animationInterval);
                }
                
                const animationSpeed = 11 - document.getElementById('animationSpeed').value;
                document.getElementById('startAnimationBtn').disabled = true;
                document.getElementById('pauseAnimationBtn').disabled = false;
                document.getElementById('stopAnimationBtn').disabled = false;
                
                // Reset all nodes to original color
                const animationData = animationNetwork.body.data;
                animationData.nodes.forEach(node => {
                    animationData.nodes.update({
                        id: node.id,
                        color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                    });
                });
                
                // Start animation loop
                animationInterval = setInterval(() => {
                    if (currentAnimationStep >= animationSteps.length) {
                        clearInterval(animationInterval);
                        document.getElementById('startAnimationBtn').disabled = false;
                        document.getElementById('pauseAnimationBtn').disabled = true;
                        document.getElementById('stopAnimationBtn').disabled = true;
                        
                        // Mark animation as complete
                        document.getElementById('animationSteps').innerHTML += `<div class="text-green-500 font-medium mt-2">Traversal complete!</div>`;
                        return;
                    }
                    
                    const step = animationSteps[currentAnimationStep];
                    
                    // Update node appearance based on action
                    let color = '';
                    switch (step.action) {
                        case 'visit':
                            color = '#FCD34D'; // Yellow
                            break;
                        case 'process':
                            color = '#34D399'; // Green
                            break;
                        case 'goLeft':
                        case 'goRight':
                        case 'checkLeft':
                        case 'checkRight':
                            color = '#60A5FA'; // Blue
                            break;
                        case 'returnFromLeft':
                        case 'returnFromRight':
                            color = '#A78BFA'; // Purple
                            break;
                        case 'noLeft':
                        case 'noRight':
                            color = '#F87171'; // Red
                            break;
                    }
                    
                    // Update node color
                    animationNetwork.body.data.nodes.update({
                        id: step.node,
                        color: { background: color }
                    });
                    
                    // Add step description to the log
                    const stepLog = `<div class="py-1 border-b border-gray-200">
                        <span class="font-medium">Step ${currentAnimationStep + 1}:</span> ${step.description}
                    </div>`;
                    
                    document.getElementById('animationSteps').innerHTML += stepLog;
                    
                    // Auto-scroll to the bottom
                    const stepsContainer = document.getElementById('animationSteps');
                    stepsContainer.scrollTop = stepsContainer.scrollHeight;
                    
                    currentAnimationStep++;
                }, animationSpeed * 300);
            }
            
            // Pause the animation
            function pauseAnimation() {
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                    document.getElementById('startAnimationBtn').disabled = false;
                    document.getElementById('pauseAnimationBtn').disabled = true;
                }
            }
            
            // Stop the animation
            function stopAnimation() {
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                
                // Reset animation state
                currentAnimationStep = 0;
                document.getElementById('startAnimationBtn').disabled = false;
                document.getElementById('pauseAnimationBtn').disabled = true;
                document.getElementById('stopAnimationBtn').disabled = true;
                
                // Reset node colors
                const animationData = animationNetwork.body.data;
                animationData.nodes.forEach(node => {
                    animationData.nodes.update({
                        id: node.id,
                        color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                    });
                });
                
                // Clear animation steps display
                document.getElementById('animationSteps').innerHTML = `<div class="text-gray-500">Animation stopped. Click Play to restart.</div>`;
            }
            
            // Show toast notification
            function showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                
                // Set color based on type
                switch (type) {
                    case 'success':
                        toast.className = 'toast toast-success';
                        break;
                    case 'error':
                        toast.className = 'toast toast-error';
                        break;
                    case 'warning':
                        toast.className = 'toast toast-warning';
                        break;
                    default:
                        toast.className = 'toast toast-info';
                }
                
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            function compareTreesHandler() {
                const tree1Input = document.getElementById('compareTree1').value;
                const tree2Input = document.getElementById('compareTree2').value;
                
                if (!tree1Input || !tree2Input) {
                    showToast('Please enter values for both trees', 'error');
                    return;
                }
                
                // Parse tree inputs
                let tree1, tree2;
                try {
                    tree1 = parseTreeInput(tree1Input);
                    tree2 = parseTreeInput(tree2Input);
                } catch (error) {
                    showToast('Error parsing tree input: ' + error.message, 'error');
                    return;
                }
                
                // Compare trees
                compareAndDisplayResults(tree1, tree2);
            }
            
            function parseTreeInput(input) {
                // Support both JSON and array formats
                try {
                    // Try as JSON
                    return JSON.parse(input);
                } catch (e) {
                    // Try as array of values
                    try {
                        const values = input.split(',').map(val => {
                            const trimmed = val.trim();
                            return isNaN(parseInt(trimmed)) ? trimmed : parseInt(trimmed);
                        });
                        
                        return buildTreeFromArray(values);
                    } catch (err) {
                        throw new Error('Invalid input format');
                    }
                }
            }
            
            function buildTreeFromArray(arr) {
                if (!arr || arr.length === 0) return null;
                
                const root = { value: arr[0], left: null, right: null };
                const queue = [root];
                let i = 1;
                
                while (i < arr.length) {
                    const node = queue.shift();
                    
                    // Add left child
                    if (i < arr.length && arr[i] !== null) {
                        node.left = { value: arr[i], left: null, right: null };
                        queue.push(node.left);
                    }
                    i++;
                    
                    // Add right child
                    if (i < arr.length && arr[i] !== null) {
                        node.right = { value: arr[i], left: null, right: null };
                        queue.push(node.right);
                    }
                    i++;
                }
                
                return root;
            }
            
            function compareAndDisplayResults(tree1, tree2) {
                const results = document.getElementById('comparisonResults');
                
                // Basic structural comparison
                function areStructurallyIdentical(a, b) {
                    if (!a && !b) return true;
                    if (!a || !b) return false;
                    
                    return (
                        areStructurallyIdentical(a.left, b.left) && 
                        areStructurallyIdentical(a.right, b.right)
                    );
                }
                
                // Check if values are identical
                function areValuesIdentical(a, b) {
                    if (!a && !b) return true;
                    if (!a || !b) return false;
                    
                    return (
                        a.value === b.value && 
                        areValuesIdentical(a.left, b.left) && 
                        areValuesIdentical(a.right, b.right)
                    );
                }
                
                // Compare heights
                function calculateHeight(node) {
                    if (!node) return -1;
                    return Math.max(calculateHeight(node.left), calculateHeight(node.right)) + 1;
                }
                
                // Calculate node count
                function calculateNodeCount(node) {
                    if (!node) return 0;
                    return calculateNodeCount(node.left) + calculateNodeCount(node.right) + 1;
                }
                
                // Compare BST property
                function isBST(node, min = -Infinity, max = Infinity) {
                    if (!node) return true;
                    
                    if (node.value <= min || node.value >= max) {
                        return false;
                    }
                    
                    return isBST(node.left, min, node.value) && isBST(node.right, node.value, max);
                }
                
                // Compare tree traversals
                function getInOrder(node, result = []) {
                    if (!node) return result;
                    
                    getInOrder(node.left, result);
                    result.push(node.value);
                    getInOrder(node.right, result);
                    
                    return result;
                }
                
                function getPreOrder(node, result = []) {
                    if (!node) return result;
                    
                    result.push(node.value);
                    getPreOrder(node.left, result);
                    getPreOrder(node.right, result);
                    
                    return result;
                }
                
                function getPostOrder(node, result = []) {
                    if (!node) return result;
                    
                    getPostOrder(node.left, result);
                    getPostOrder(node.right, result);
                    result.push(node.value);
                    
                    return result;
                }
                
                // Get comparison results
                const structurallyIdentical = areStructurallyIdentical(tree1, tree2);
                const valuesIdentical = areValuesIdentical(tree1, tree2);
                const height1 = calculateHeight(tree1);
                const height2 = calculateHeight(tree2);
                const nodeCount1 = calculateNodeCount(tree1);
                const nodeCount2 = calculateNodeCount(tree2);
                const isBST1 = isBST(tree1);
                const isBST2 = isBST(tree2);
                
                const inOrder1 = getInOrder(tree1);
                const inOrder2 = getInOrder(tree2);
                const preOrder1 = getPreOrder(tree1);
                const preOrder2 = getPreOrder(tree2);
                const sameInOrder = JSON.stringify(inOrder1) === JSON.stringify(inOrder2);
                const samePreOrder = JSON.stringify(preOrder1) === JSON.stringify(preOrder2);
                
                // Display results
                results.innerHTML = `
                    <div class="p-4 bg-white rounded-lg shadow">
                        <h3 class="text-lg font-semibold mb-3">Comparison Results</h3>
                        
                        <div class="mb-4">
                            <span class="font-medium">Overall Status:</span> 
                            ${valuesIdentical ? 
                                '<span class="text-green-600">Trees are identical</span>' : 
                                '<span class="text-red-600">Trees differ</span>'
                            }
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <h4 class="font-medium mb-2">Tree 1</h4>
                                <ul class="text-sm space-y-1">
                                    <li>Height: ${height1}</li>
                                    <li>Nodes: ${nodeCount1}</li>
                                    <li>Is BST: ${isBST1 ? 'Yes' : 'No'}</li>
                                    <li>In-order: [${inOrder1.join(', ')}]</li>
                                    <li>Pre-order: [${preOrder1.join(', ')}]</li>
                                </ul>
                            </div>
                            
                            <div>
                                <h4 class="font-medium mb-2">Tree 2</h4>
                                <ul class="text-sm space-y-1">
                                    <li>Height: ${height2}</li>
                                    <li>Nodes: ${nodeCount2}</li>
                                    <li>Is BST: ${isBST2 ? 'Yes' : 'No'}</li>
                                    <li>In-order: [${inOrder2.join(', ')}]</li>
                                    <li>Pre-order: [${preOrder2.join(', ')}]</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="mt-4 pt-3 border-t border-gray-200">
                            <h4 class="font-medium mb-2">Detailed Comparison</h4>
                            <ul class="text-sm space-y-1">
                                <li>Same Structure: ${structurallyIdentical ? 'Yes' : 'No'}</li>
                                <li>Same Values: ${valuesIdentical ? 'Yes' : 'No'}</li>
                                <li>Same In-order Traversal: ${sameInOrder ? 'Yes' : 'No'}</li>
                                <li>Same Pre-order Traversal: ${samePreOrder ? 'Yes' : 'No'}</li>
                                <li>Height Difference: ${Math.abs(height1 - height2)}</li>
                                <li>Node Count Difference: ${Math.abs(nodeCount1 - nodeCount2)}</li>
                            </ul>
                        </div>
                        
                        <div class="mt-4 pt-3 border-t border-gray-200">
                            <h4 class="font-medium mb-2">Interpretation</h4>
                            <div class="text-sm">
                                ${getComparisonInterpretation(structurallyIdentical, valuesIdentical, sameInOrder, isBST1, isBST2)}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            function getComparisonInterpretation(sameStructure, sameValues, sameInOrder, isBST1, isBST2) {
                if (sameValues) {
                    return "The trees are identical in both structure and values.";
                } else if (sameStructure) {
                    return "The trees have the same structure but different values.";
                } else if (sameInOrder && isBST1 && isBST2) {
                    return "The trees have the same in-order traversal and are both BSTs, suggesting they represent the same sorted data but with different structures.";
                } else if (sameInOrder) {
                    return "The trees have the same in-order traversal but different structures.";
                } else {
                    return "The trees are different in both structure and values.";
                }
            }
            
            // Tree search functionality
            function searchInTree() {
                const searchValue = document.getElementById('searchValue').value;
                
                if (!searchValue || !treeRoot) {
                    showToast('Please enter a search value and ensure a tree exists', 'warning');
                    return;
                }
                
                const value = isNaN(parseInt(searchValue)) ? searchValue : parseInt(searchValue);
                
                // Reset previous highlights
                clearHighlights();
                
                // Start search animation
                animateSearch(treeRoot, value);
            }
            
            function clearHighlights() {
                nodes.forEach(node => {
                    nodes.update({
                        id: node.id,
                        color: document.getElementById('nodeColorSelector').style.backgroundColor || '#3B82F6'
                    });
                });
            }
            
            function animateSearch(node, targetValue, nodeId = 1, path = []) {
                if (!node) {
                    showToast(`Value ${targetValue} not found in the tree`, 'warning');
                    return;
                }
                
                // Add current node to path
                path.push(nodeId);
                
                // Highlight search path
                highlightSearchPath(path, node.value === targetValue);
                
                // Check current node
                if (node.value === targetValue) {
                    showToast(`Found value ${targetValue}!`, 'success');
                    return;
                }
                
                // For BST search
                if (isBST(treeRoot)) {
                    // Decide whether to go left or right
                    if (targetValue < node.value) {
                        document.getElementById('searchSteps').innerHTML += `<div>Value ${targetValue} is less than ${node.value}, searching left subtree</div>`;
                        animateSearch(node.left, targetValue, 2 * nodeId, path);
                    } else {
                        document.getElementById('searchSteps').innerHTML += `<div>Value ${targetValue} is greater than ${node.value}, searching right subtree</div>`;
                        animateSearch(node.right, targetValue, 2 * nodeId + 1, path);
                    }
                } else {
                    // For non-BST, we need to search both subtrees
                    if (node.left) {
                        animateSearch(node.left, targetValue, 2 * nodeId, [...path]);
                    }
                    
                    if (node.right) {
                        animateSearch(node.right, targetValue, 2 * nodeId + 1, [...path]);
                    }
                }
            }
            
            function highlightSearchPath(path, isTarget) {
                // Clear search steps display
                document.getElementById('searchSteps').innerHTML = '';
                
                // Highlight path step by step
                let delay = 0;
                path.forEach((nodeId, index) => {
                    setTimeout(() => {
                        // Get the node value for display
                        const nodeValue = getNodeValueById(treeRoot, nodeId);
                        
                        // Add step to search steps display
                        document.getElementById('searchSteps').innerHTML += `
                            <div class="py-1 border-b border-gray-200">
                                <span class="font-medium">Step ${index + 1}:</span> Visiting node ${nodeValue}
                            </div>
                        `;
                        
                        // Highlight the node
                        const color = isTarget && index === path.length - 1 ? '#10B981' : '#FCD34D';
                        
                        nodes.update({
                            id: nodeId,
                            color: { background: color }
                        });
                        
                        // Highlight edges too
                        if (index > 0) {
                            const fromNode = path[index - 1];
                            edges.forEach(edge => {
                                if (edge.from === fromNode && edge.to === nodeId) {
                                    edges.update({
                                        id: edge.id,
                                        color: { color: '#FCD34D' }
                                    });
                                }
                            });
                        }
                        
                        // If this is the last node and the target
                        if (isTarget && index === path.length - 1) {
                            document.getElementById('searchSteps').innerHTML += `
                                <div class="py-1 text-green-600 font-medium">
                                    Found the target value!
                                </div>
                            `;
                        }
                        
                        // If this is the last node but not the target
                        if (!isTarget && index === path.length - 1) {
                            document.getElementById('searchSteps').innerHTML += `
                                <div class="py-1 text-red-600 font-medium">
                                    Target not found in this path.
                                </div>
                            `;
                        }
                    }, delay);
                    
                    delay += 500; // Adjust timing between steps
                });
            }
            
            function getNodeValueById(root, id, currentId = 1) {
                if (!root) return null;
                if (currentId === id) return root.value;
                
                const leftResult = getNodeValueById(root.left, id, 2 * currentId);
                if (leftResult !== null) return leftResult;
                
                return getNodeValueById(root.right, id, 2 * currentId + 1);
            }
            
            // Helper function to check if tree is BST
            function isBST(node, min = -Infinity, max = Infinity) {
                if (!node) return true;
                
                if (node.value <= min || node.value >= max) {
                    return false;
                }
                
                return isBST(node.left, min, node.value) && isBST(node.right, node.value, max);
            }
            
            // Export tree to various formats
            function exportTree() {
                if (!treeRoot) {
                    showToast('No tree to export', 'error');
                    return;
                }
                
                const format = document.getElementById('exportFormat').value;
                let exportData = '';
                
                switch (format) {
                    case 'json':
                        exportData = JSON.stringify(treeToJson(treeRoot), null, 2);
                        break;
                    case 'array':
                        exportData = JSON.stringify(treeToArray(treeRoot));
                        break;
                    case 'dot':
                        exportData = treeToDot(treeRoot);
                        break;
                    case 'svg':
                        exportDataAsSVG();
                        return;
                }
                
                document.getElementById('exportOutput').value = exportData;
            }
            
            function treeToArray(root) {
                if (!root) return [];
                
                const result = [];
                const queue = [root];
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    
                    if (node) {
                        result.push(node.value);
                        queue.push(node.left || null);
                        queue.push(node.right || null);
                    } else {
                        result.push(null);
                    }
                }
                
                // Trim trailing nulls
                while (result[result.length - 1] === null) {
                    result.pop();
                }
                
                return result;
            }
            
            function treeToDot(root) {
                let dotContent = 'digraph G {\n';
                
                function traverse(node, id = 1) {
                    if (!node) return;
                    
                    dotContent += `  ${id} [label="${node.value}"];\n`;
                    
                    if (node.left) {
                        const leftId = 2 * id;
                        dotContent += `  ${id} -> ${leftId};\n`;
                        traverse(node.left, leftId);
                    }
                    
                    if (node.right) {
                        const rightId = 2 * id + 1;
                        dotContent += `  ${id} -> ${rightId};\n`;
                        traverse(node.right, rightId);
                    }
                }
                
                traverse(root);
                dotContent += '}';
                
                return dotContent;
            }
            
            function exportDataAsSVG() {
                const svgElement = network.canvas.frame.getElementsByTagName('svg')[0];
                const svgData = new XMLSerializer().serializeToString(svgElement);
                
                document.getElementById('exportOutput').value = svgData;
            }
            
            // Tree import functionality
            function importTree() {
                const importData = document.getElementById('importData').value;
                const format = document.getElementById('importFormat').value;
                
                if (!importData) {
                    showToast('Please enter data to import', 'error');
                    return;
                }
                
                try {
                    let parsedTree;
                    
                    switch (format) {
                        case 'json':
                            parsedTree = JSON.parse(importData);
                            treeRoot = parsedTree;
                            break;
                        case 'array':
                            const array = JSON.parse(importData);
                            treeRoot = buildTreeFromArray(array);
                            break;
                        case 'bracket':
                            treeRoot = parseBracketNotation(importData);
                            break;
                    }
                    
                    // Regenerate visualization
                    visualizeTree(treeRoot);
                    showToast('Tree imported successfully!', 'success');
                    
                    // Update analysis
                    analyzeTree(treeRoot);
                    displayTraversals(treeRoot);
                } catch (error) {
                    showToast('Error importing tree: ' + error.message, 'error');
                }
            }
            
            function parseBracketNotation(notation) {
                // Simple parser for bracket notation like "1(2,3(4,5))"
                notation = notation.trim();
                
                if (!notation) return null;
                
                const getValue = (str) => {
                    const match = str.match(/^[^(),]+/);
                    return match ? match[0].trim() : null;
                };
                
                const parseNode = (str, start = 0) => {
                    if (start >= str.length) return { node: null, end: start };
                    
                    let i = start;
                    const value = getValue(str.substring(i));
                    if (!value) return { node: null, end: i };
                    
                    i += value.length;
                    const node = { value: isNaN(parseInt(value)) ? value : parseInt(value), left: null, right: null };
                    
                    if (i < str.length && str[i] === '(') {
                        i++; // Skip '('
                        
                        // Parse left child
                        const leftResult = parseNode(str, i);
                        node.left = leftResult.node;
                        i = leftResult.end;
                        
                        if (i < str.length && str[i] === ',') {
                            i++; // Skip ','
                            
                            // Parse right child
                            const rightResult = parseNode(str, i);
                            node.right = rightResult.node;
                            i = rightResult.end;
                        }
                        
                        if (i < str.length && str[i] === ')') {
                            i++; // Skip ')'
                        }
                    }
                    
                    return { node, end: i };
                };
                
                return parseNode(notation).node;
            }
            
            // Initialize event listeners
            function initEventListeners() {
                // Tab switching
                document.getElementById('textTabBtn').addEventListener('click', function() {
                    document.getElementById('textTabBtn').classList.add('active');
                    document.getElementById('jsonTabBtn').classList.remove('active');
                    document.getElementById('visualTabBtn').classList.remove('active');
                    document.getElementById('textInputTab').classList.remove('hidden');
                    document.getElementById('jsonInputTab').classList.add('hidden');
                    document.getElementById('visualInputTab').classList.add('hidden');
                });
                
                document.getElementById('jsonTabBtn').addEventListener('click', function() {
                    document.getElementById('textTabBtn').classList.remove('active');
                    document.getElementById('jsonTabBtn').classList.add('active');
                    document.getElementById('visualTabBtn').classList.remove('active');
                    document.getElementById('textInputTab').classList.add('hidden');
                    document.getElementById('jsonInputTab').classList.remove('hidden');
                    document.getElementById('visualInputTab').classList.add('hidden');
                });
                
                document.getElementById('visualTabBtn').addEventListener('click', function() {
                    document.getElementById('textTabBtn').classList.remove('active');
                    document.getElementById('jsonTabBtn').classList.remove('active');
                    document.getElementById('visualTabBtn').classList.add('active');
                    document.getElementById('textInputTab').classList.add('hidden');
                    document.getElementById('jsonInputTab').classList.add('hidden');
                    document.getElementById('visualInputTab').classList.remove('hidden');
                });
                
                // Visualization tabs
                document.getElementById('visualizationTabBtn').addEventListener('click', function() {
                    document.getElementById('visualizationTabBtn').classList.add('active');
                    document.getElementById('animationTabBtn').classList.remove('active');
                    document.getElementById('comparisonTabBtn').classList.remove('active');
                    document.getElementById('visualizationTab').classList.remove('hidden');
                    document.getElementById('animationTab').classList.add('hidden');
                    document.getElementById('comparisonTab').classList.add('hidden');
                });
                
                document.getElementById('animationTabBtn').addEventListener('click', function() {
                    document.getElementById('visualizationTabBtn').classList.remove('active');
                    document.getElementById('animationTabBtn').classList.add('active');
                    document.getElementById('comparisonTabBtn').classList.remove('active');
                    document.getElementById('visualizationTab').classList.add('hidden');
                    document.getElementById('animationTab').classList.remove('hidden');
                    document.getElementById('comparisonTab').classList.add('hidden');
                    setupAnimationTraversal();
                });
                
                document.getElementById('comparisonTabBtn').addEventListener('click', function() {
                    document.getElementById('visualizationTabBtn').classList.remove('active');
                    document.getElementById('animationTabBtn').classList.remove('active');
                    document.getElementById('comparisonTabBtn').classList.add('active');
                    document.getElementById('visualizationTab').classList.add('hidden');
                    document.getElementById('animationTab').classList.add('hidden');
                    document.getElementById('comparisonTab').classList.remove('hidden');
                });
                
                // Main buttons
                document.getElementById('generateTreeBtn').addEventListener('click', function() {
                    const activeTab = document.querySelector('.tab.active');
                    let root = null;
                    
                    if (activeTab.id === 'textTabBtn') {
                        const input = document.getElementById('treeTextInput').value;
                        const values = input.split(',').map(val => val.trim());
                        root = createTreeFromArray(values);
                    } else if (activeTab.id === 'jsonTabBtn') {
                        const json = document.getElementById('treeJsonInput').value;
                        root = createTreeFromJson(json);
                    } else {
                        // For visual tab, we already have the network
                        return;
                    }
                    
                    treeRoot = root;
                    visualizeTree(root);
                    analyzeTree(root);
                    displayTraversals(root);
                });
                
                document.getElementById('analyzeTreeBtn').addEventListener('click', function() {
                    if (!treeRoot) {
                        showToast('Please generate a tree first', 'error');
                        return;
                    }
                    analyzeTree(treeRoot);
                    displayTraversals(treeRoot);
                });
                
                // Example tree buttons
                document.querySelectorAll('.example-tree-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const values = this.getAttribute('data-values');
                        document.getElementById('treeTextInput').value = values;
                        document.getElementById('textTabBtn').click();
                    });
                });
                
                // Clear graph button
                document.getElementById('clearGraphBtn').addEventListener('click', function() {
                    nodes.clear();
                    edges.clear();
                    currentNodeId = 0;
                    treeRoot = null;
                    resetAnalysisFields();
                });
                
                // Auto layout button
                document.getElementById('autoLayoutBtn').addEventListener('click', function() {
                    network.setOptions({
                        layout: {
                            hierarchical: {
                                direction: 'UD',
                                sortMethod: 'directed'
                            }
                        }
                    });
                });
                
                // Zoom controls
                document.getElementById('zoomInBtn').addEventListener('click', function() {
                    network.moveTo({
                        scale: network.getScale() * 1.2
                    });
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', function() {
                    network.moveTo({
                        scale: network.getScale() / 1.2
                    });
                });
                
                document.getElementById('resetZoomBtn').addEventListener('click', function() {
                    network.fit();
                });
                
                // Edge style change
                document.getElementById('edgeStyle').addEventListener('change', updateEdgeStyle);
                
                // Node color selector
                document.getElementById('nodeColorSelector').addEventListener('click', function() {
                    const color = prompt('Enter hex color (e.g. #3B82F6):', this.style.backgroundColor || '#3B82F6');
                    if (color) {
                        this.style.backgroundColor = color;
                    }
                });
                
                // Color options
                document.querySelectorAll('.color-option').forEach(option => {
                    option.addEventListener('click', function() {
                        const color = this.getAttribute('data-color');
                        document.getElementById('nodeColorSelector').style.backgroundColor = color;
                    });
                });
                
                // Animation controls
                document.getElementById('startAnimationBtn').addEventListener('click', startAnimation);
                document.getElementById('pauseAnimationBtn').addEventListener('click', pauseAnimation);
                document.getElementById('stopAnimationBtn').addEventListener('click', stopAnimation);
                
                // Compare trees button
                document.getElementById('compareTreesBtn').addEventListener('click', compareTreesHandler);
                
                // Advanced features toggle
                document.getElementById('advancedToggle').addEventListener('click', function() {
                    const content = document.getElementById('advancedContent');
                    const chevron = document.getElementById('advancedChevron');
                    
                    if (content.classList.contains('hidden')) {
                        content.classList.remove('hidden');
                        chevron.classList.remove('fa-chevron-down');
                        chevron.classList.add('fa-chevron-up');
                    } else {
                        content.classList.add('hidden');
                        chevron.classList.remove('fa-chevron-up');
                        chevron.classList.add('fa-chevron-down');
                    }
                });
                
                // Execute operation button
                document.getElementById('executeOperationBtn').addEventListener('click', function() {
                    const operation = document.getElementById('treeOperation').value;
                    const params = document.getElementById('operationParams').value;
                    
                    if (!treeRoot) {
                        showToast('Please generate a tree first', 'error');
                        return;
                    }
                    
                    let result = '';
                    
                    switch (operation) {
                        case 'serialize':
                            result = JSON.stringify(treeToJson(treeRoot), null, 2);
                            break;
                        case 'deserialize':
                            try {
                                const json = JSON.parse(params);
                                treeRoot = createTreeFromJson(json);
                                visualizeTree(treeRoot);
                                analyzeTree(treeRoot);
                                displayTraversals(treeRoot);
                                result = 'Tree deserialized successfully!';
                            } catch (e) {
                                result = 'Error: Invalid JSON format';
                            }
                            break;
                        case 'mirror':
                            mirrorTree(treeRoot);
                            visualizeTree(treeRoot);
                            analyzeTree(treeRoot);
                            displayTraversals(treeRoot);
                            result = 'Tree mirrored successfully!';
                            break;
                        case 'subtree':
                            try {
                                const subtree = createTreeFromJson(params);
                                const found = isSubtree(treeRoot, subtree);
                                result = found ? 'Subtree found!' : 'Subtree not found';
                            } catch (e) {
                                result = 'Error: Invalid subtree format';
                            }
                            break;
                        case 'lca':
                            const nodes = params.split(',').map(val => val.trim());
                            if (nodes.length !== 2) {
                                result = 'Please enter two node values separated by comma';
                            } else {
                                const lca = findLCA(treeRoot, nodes[0], nodes[1]);
                                result = lca ? `Lowest Common Ancestor: ${lca.value}` : 'No common ancestor found';
                            }
                            break;
                        case 'path':
                            const pathNodes = params.split(',').map(val => val.trim());
                            if (pathNodes.length !== 2) {
                                result = 'Please enter two node values separated by comma';
                            } else {
                                const path = findPath(treeRoot, pathNodes[0], pathNodes[1]);
                                result = path ? `Path: ${path.join(' -> ')}` : 'No path found';
                            }
                            break;
                        case 'serialize':
                            const list = treeToLinkedList(treeRoot);
                            result = 'Linked List: ' + list.join(' -> ');
                            break;
                    }
                    
                    document.getElementById('operationResult').textContent = result;
                });
                
                // Helper functions for operations
                function mirrorTree(node) {
                    if (!node) return;
                    
                    // Swap left and right subtrees
                    const temp = node.left;
                    node.left = node.right;
                    node.right = temp;
                    
                    // Recursively mirror subtrees
                    mirrorTree(node.left);
                    mirrorTree(node.right);
                }
                
                function isSubtree(tree, subtree) {
                    if (!subtree) return true;
                    if (!tree) return false;
                    
                    if (areIdentical(tree, subtree)) {
                        return true;
                    }
                    
                    return isSubtree(tree.left, subtree) || isSubtree(tree.right, subtree);
                }
                
                function areIdentical(a, b) {
                    if (!a && !b) return true;
                    if (!a || !b) return false;
                    
                    return (a.value === b.value) && 
                           areIdentical(a.left, b.left) && 
                           areIdentical(a.right, b.right);
                }
                
                function findLCA(root, val1, val2) {
                    if (!root) return null;
                    
                    if (root.value === val1 || root.value === val2) {
                        return root;
                    }
                    
                    const leftLCA = findLCA(root.left, val1, val2);
                    const rightLCA = findLCA(root.right, val1, val2);
                    
                    if (leftLCA && rightLCA) {
                        return root;
                    }
                    
                    return leftLCA ? leftLCA : rightLCA;
                }
                
                function findPath(root, val1, val2) {
                    const lca = findLCA(root, val1, val2);
                    if (!lca) return null;
                    
                    const path1 = [];
                    const path2 = [];
                    
                    getPath(lca, val1, path1);
                    getPath(lca, val2, path2);
                    
                    // Remove the LCA from one of the paths to avoid duplication
                    path1.pop();
                    
                    // Combine paths
                    return [...path1.reverse(), lca.value, ...path2];
                }
                
                function getPath(node, val, path) {
                    if (!node) return false;
                    
                    path.push(node.value);
                    
                    if (node.value === val) {
                        return true;
                    }
                    
                    if (getPath(node.left, val, path) || getPath(node.right, val, path)) {
                        return true;
                    }
                    
                    path.pop();
                    return false;
                }
                
                function treeToLinkedList(root) {
                    const result = [];
                    inOrderTraversal(root, result);
                    return result;
                }
                
                // Modal controls
                document.getElementById('helpBtn').addEventListener('click', function() {
                    document.getElementById('helpModal').style.display = 'block';
                });
                
                document.getElementById('settingsBtn').addEventListener('click', function() {
                    document.getElementById('settingsModal').style.display = 'block';
                });
                
                document.getElementById('expandAnalysisBtn').addEventListener('click', function() {
                    document.getElementById('analysisDetailModal').style.display = 'block';
                });
                
                document.querySelectorAll('.close-modal').forEach(btn => {
                    btn.addEventListener('click', function() {
                        this.closest('.modal').style.display = 'none';
                    });
                });
                
                // Close modal when clicking outside
                window.addEventListener('click', function(event) {
                    if (event.target.classList.contains('modal')) {
                        event.target.style.display = 'none';
                    }
                });
                
                // Theme toggle
                document.getElementById('themeToggle').addEventListener('click', function() {
                    darkModeEnabled = !darkModeEnabled;
                    if (darkModeEnabled) {
                        document.body.classList.add('bg-gray-900', 'text-white');
                        document.body.classList.remove('bg-gray-50');
                        this.innerHTML = '<i class="fas fa-sun"></i>';
                    } else {
                        document.body.classList.remove('bg-gray-900', 'text-white');
                        document.body.classList.add('bg-gray-50');
                        this.innerHTML = '<i class="fas fa-moon"></i>';
                    }
                });
                
                // Save settings
                document.getElementById('saveSettingsBtn').addEventListener('click', function() {
                    const edgeStyle = document.getElementById('defaultEdgeStyle').value;
                    const animationSpeed = document.getElementById('defaultAnimationSpeed').value;
                    const nodeColor = document.getElementById('nodeColorSelector').style.backgroundColor;
                    
                    // Apply settings
                    document.getElementById('edgeStyle').value = edgeStyle;
                    updateEdgeStyle();
                    
                    document.getElementById('animationSpeed').value = animationSpeed;
                    
                    if (nodeColor) {
                        document.getElementById('nodeColorSelector').style.backgroundColor = nodeColor;
                    }
                    
                    // Save to localStorage
                    localStorage.setItem('treeSettings', JSON.stringify({
                        edgeStyle,
                        animationSpeed,
                        nodeColor
                    }));
                    
                    showToast('Settings saved!', 'success');
                    document.getElementById('settingsModal').style.display = 'none';
                });
                
                // Load settings
                function loadSettings() {
                    const settings = JSON.parse(localStorage.getItem('treeSettings'));
                    if (settings) {
                        document.getElementById('defaultEdgeStyle').value = settings.edgeStyle || 'curved';
                        document.getElementById('defaultAnimationSpeed').value = settings.animationSpeed || 5;
                        
                        if (settings.nodeColor) {
                            document.getElementById('nodeColorSelector').style.backgroundColor = settings.nodeColor;
                        }
                    }
                }
                
                // Initialize
                initNetwork();
                initEventListeners();
                loadSettings();
            }
            
            // Start the application
            initEventListeners();
        });
    </script>
</body>
</html>